{
  "language": "Solidity",
  "sources": {
    "contracts/CarPooling.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.24;\n\n// Create ride\n// book ride\n// withdraw money for ride\n// cancel ride :- driver(return all money back to passengers), passenger(return deducted amount back to passenger)\n// get all ride :- either make an array to save keys in contract itself or use getALL for the first time to get all the keys then maintain them in the frontend\n// get index function :- to remove repeated code for getting the index\n\n// Tests\n// create a ride\n// get all rides, single ride and user rides\n// book a ride\n// mark completion status by passenger\n// cancel by passenger and by driver\n// withdraw money via driver\n\nerror ERROR_CarPooling(string message);\n\ncontract CarPooling {\n    struct Ride {\n        address driver; // time // locations (source and destination)\n        address[] passengers;\n        uint256 maxPassengers;\n        uint256 rideFare; // co ordinates des co ordinates save -- passenger ride filter\n        uint256 rideId;\n        uint256 time; // startTime\n        string tripDetails; // source and des\n        string carDetails; // car type ac non ac\n    }\n\n    mapping(uint256 => Ride) public rides;\n    mapping(address => uint256[]) public addressToRides;\n    mapping(uint256 => uint256) public completionStatus;\n\n    uint256 public rideCount = 0;\n    uint256[] public rideKeys; // delete when ride is cancelled\n\n    function createRide(\n        uint256 mp,\n        uint256 rf,\n        uint256 t,\n        string memory td,\n        string memory cd\n    ) public {\n        rideCount += 1;\n        uint256 rid = rideCount;\n        address[] memory p;\n        rides[rid] = Ride(msg.sender, p, mp, rf, rid, t, td, cd);\n\n        addressToRides[msg.sender].push(rid);\n        completionStatus[rid] = 0;\n        rideKeys.push(rid);\n    }\n\n    function bookRide(uint256 rideId) public payable duplicate(rideId) {\n        rides[rideId].passengers.push(msg.sender);\n        addressToRides[msg.sender].push(rideId);\n    }\n\n    modifier duplicate(uint256 rideId) {\n        Ride memory r = rides[rideId];\n        if (msg.sender == r.driver || r.passengers.length == r.maxPassengers) {\n            revert ERROR_CarPooling({\n                message: \"Driver cannot book the ride or maximum passengers reached\"\n            });\n        }\n        for (uint256 i = 0; i < r.passengers.length; i++) {\n            if (msg.sender == r.passengers[i]) {\n                revert ERROR_CarPooling({\n                    message: \"You have already booked the ride\"\n                });\n            }\n        }\n        _;\n    }\n\n    function updateStatus(uint256 rideId) public {\n        // completion of ride by passengers\n        address passenger = msg.sender;\n        uint256[] memory pRides = addressToRides[passenger];\n        (bool exists, uint256 index) = getIndex(pRides, rideId);\n\n        if (!exists) {\n            revert ERROR_CarPooling({\n                message: \"Ride is not registered with passenger\"\n            });\n        }\n\n        completionStatus[rideId] += 1;\n\n        // erase this ride from passengers list\n        addressToRides[passenger][index] = pRides[pRides.length - 1];\n        addressToRides[passenger].pop();\n    }\n\n    function rideCompleted(uint256 rideId) public {\n        // driver withdrawing money\n        if (msg.sender != rides[rideId].driver) {\n            revert ERROR_CarPooling({message: \"Sender is not the driver\"});\n        }\n        if (completionStatus[rideId] != rides[rideId].passengers.length) {\n            revert ERROR_CarPooling({\n                message: \"Not all passengers have marked the ride as completed\"\n            });\n        }\n\n        uint256 count = rides[rideId].passengers.length;\n        uint256 amount = count * rides[rideId].rideFare;\n        amount = amount * 1e18;\n\n        (bool callSuccess, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(callSuccess, \"Call method failed\");\n\n        // erase ride from drivers list erase completion status for this ride id\n        completionStatus[rideId] = 0;\n        uint256[] memory driverRides = addressToRides[msg.sender];\n        (bool exists, uint256 index) = getIndex(driverRides, rideId);\n\n        if (!exists) {\n            revert ERROR_CarPooling({\n                message: \"Ride is not registerd with driver\"\n            });\n        }\n\n        addressToRides[msg.sender][index] = driverRides[driverRides.length - 1];\n        addressToRides[msg.sender].pop();\n\n        // erase ride from rides mapping as ride is completed\n        rides[rideId] = rides[0]; // rides[0] is never given anything so will put default values back in rideId\n\n        // erase rideId from rideKeys\n        uint256[] memory keys = rideKeys;\n        (exists, index) = getIndex(keys, rideId);\n\n        if (!exists) {\n            revert ERROR_CarPooling({message: \"Key does not exist\"});\n        }\n\n        rideKeys[index] = keys[keys.length - 1];\n        rideKeys.pop();\n    }\n\n    function cancelRide(uint256 rideId) public {\n        // two cases\n        // 1. Either cancelled by the driver\n        // 2. Or cancelled by one of the passegners\n\n        Ride memory r = rides[rideId];\n        if (msg.sender == r.driver) {\n            // return full money back to all passengers\n            address[] memory passengers = r.passengers;\n            uint256 amount = r.rideFare;\n            amount = amount * 1e18;\n\n            for (uint256 i = 0; i < passengers.length; i++) {\n                address p = passengers[i];\n                (bool callSuccess, ) = payable(p).call{value: amount}(\"\");\n                require(callSuccess, \"Call method failed\");\n            }\n\n            // remove ride from driver's list\n            uint256[] memory driverRides = addressToRides[msg.sender];\n            (bool exists, uint256 index) = getIndex(driverRides, rideId);\n\n            if (!exists) {\n                revert ERROR_CarPooling(\"Ride is not registered with the user\");\n            }\n\n            addressToRides[msg.sender][index] = driverRides[\n                driverRides.length - 1\n            ];\n            addressToRides[msg.sender].pop();\n\n            // remove ride from rides mapping as well as the ride is deleted\n            rides[rideId] = rides[0];\n\n            // remove the rideId from ride keys\n            uint256[] memory keys = rideKeys;\n            (exists, index) = getIndex(keys, rideId);\n\n            if (!exists) {\n                revert ERROR_CarPooling(\"Key does not exist\");\n            }\n\n            rideKeys[index] = keys[keys.length - 1];\n            rideKeys.pop();\n\n            // reset the completion status\n            completionStatus[rideId] = 0;\n        } else {\n            // passenger cancels\n            // erase address from rides passenger array\n            uint256 index;\n            address passenger = msg.sender;\n            address[] memory passengers = r.passengers;\n            for (uint256 i = 0; i < passengers.length; i++) {\n                if (passengers[i] == passenger) {\n                    index = i;\n                    break;\n                }\n            }\n            rides[rideId].passengers[index] = passengers[passengers.length - 1];\n            rides[rideId].passengers.pop();\n\n            // erases ride from passengers rides list\n            bool exists;\n            uint256[] memory userRides = addressToRides[passenger];\n            (exists, index) = getIndex(userRides, rideId);\n            if (!exists) {\n                revert ERROR_CarPooling(\"Ride is not registered with user\");\n            }\n            addressToRides[msg.sender][index] = userRides[userRides.length - 1];\n            addressToRides[msg.sender].pop();\n\n            // return half of the money back to passenger  ( can make it time based in future)\n            uint256 amount = r.rideFare;\n            amount = amount / 2;\n            amount = amount * 1e18;\n            (bool callSuccess1, ) = payable(passenger).call{value: amount}(\"\");\n            require(callSuccess1, \"Call method failed\");\n\n            // compensate the driver with some money, half of ride fare as of now (fixed amount or maybe some time based amount for him as well)\n            (bool callSuccess2, ) = payable(r.driver).call{value: amount}(\"\");\n            require(callSuccess2, \"Call method failed\");\n        }\n    }\n\n    function getIndex(\n        uint256[] memory array,\n        uint256 val\n    ) public pure returns (bool, uint256) {\n        uint256 index = 0;\n        bool exists = false;\n        for (uint256 i = 0; i < array.length; i++) {\n            if (array[i] == val) {\n                index = i;\n                exists = true;\n                break;\n            }\n        }\n\n        return (exists, index);\n    }\n\n    function getRide(\n        uint256 rideId\n    )\n        public\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            string memory,\n            string memory\n        )\n    {\n        Ride memory r = rides[rideId];\n        return (\n            r.driver,\n            r.passengers.length,\n            r.maxPassengers,\n            r.rideFare,\n            r.rideId,\n            r.time,\n            r.tripDetails,\n            r.carDetails\n        );\n    }\n\n    function getUserRides()\n        public\n        view\n        returns (\n            address[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            string[] memory\n        )\n    {\n        uint256[] memory userRides = addressToRides[msg.sender];\n\n        address[] memory drivers = new address[](userRides.length);\n        uint256[] memory currentPassengers = new uint256[](userRides.length);\n        uint256[] memory maxPassengers = new uint256[](userRides.length);\n        uint256[] memory rideFare = new uint256[](userRides.length);\n        uint256[] memory rideId = new uint256[](userRides.length);\n        uint256[] memory time = new uint256[](userRides.length);\n        string[] memory td = new string[](userRides.length);\n        string[] memory cd = new string[](userRides.length);\n\n        for (uint256 i = 0; i < userRides.length; i++) {\n            Ride memory r = rides[userRides[i]]; // CHECK IF RIDE EXISTS FOR GIVEN ID OR NOT\n            if (r.rideId != 0) {\n                drivers[i] = r.driver;\n                currentPassengers[i] = r.passengers.length;\n                maxPassengers[i] = r.maxPassengers;\n                rideFare[i] = r.rideFare;\n                rideId[i] = r.rideId;\n                time[i] = r.time;\n                td[i] = r.tripDetails;\n                cd[i] = r.carDetails;\n            }\n        }\n\n        return (\n            drivers,\n            currentPassengers,\n            maxPassengers,\n            rideFare,\n            rideId,\n            time,\n            td\n        ); // cd not sent coz stack too deep error find a fix\n    }\n\n    function getAllRides()\n        public\n        view\n        returns (\n            address[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            uint256[] memory,\n            string[] memory\n        )\n    {\n        uint256[] memory keys = rideKeys;\n\n        address[] memory drivers = new address[](keys.length);\n        uint256[] memory currentPassengers = new uint256[](keys.length);\n        uint256[] memory maxPassengers = new uint256[](keys.length);\n        uint256[] memory rideFare = new uint256[](keys.length);\n        uint256[] memory rideId = new uint256[](keys.length);\n        uint256[] memory time = new uint256[](keys.length);\n        string[] memory td = new string[](keys.length);\n        string[] memory cd = new string[](keys.length);\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            Ride memory r = rides[keys[i]]; // CHECK IF RIDE EXISTS FOR GIVEN ID OR NOT\n            if (r.rideId != 0) {\n                drivers[i] = r.driver;\n                currentPassengers[i] = r.passengers.length;\n                maxPassengers[i] = r.maxPassengers;\n                rideFare[i] = r.rideFare;\n                rideId[i] = r.rideId;\n                time[i] = r.time;\n                td[i] = r.tripDetails;\n                cd[i] = r.carDetails;\n            }\n        }\n\n        return (\n            drivers,\n            currentPassengers,\n            maxPassengers,\n            rideFare,\n            rideId,\n            time,\n            td\n        ); // need to add cd fix stack error\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}